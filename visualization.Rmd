---
title: "Visualization in R"
author: "Matrix_Chen"
output:
  pdf_document:
    includes:
      in_header: header.tex
    keep_tex: yes   
    latex_engine: xelatex
  word_document: default
  html_document: default
---

概述：这则教程旨在介绍R语言中实现数据可视化的方法，主要介绍ggplot2包的基本用法。

#ggplot2基本用法

##基本思想：

1. ggplot2的核心理念是将绘图与数据分离，数据相关的绘图与数据无关的绘图分离
2. ggplot2是按图层作图
3. ggplot2保有命令式作图的调整函数，使其更具灵活性
4. ggplot2将常见的统计变换融入到了绘图中

##qplot()函数实现快速绘图

**基本语法：**

```{r}
# qplot(x, y = NULL, ..., data, facets = NULL,
#       margins = FALSE,geom = "auto", stat = list(NULL),
#       position = list(NULL), xlim = c(NA,NA),
#       ylim = c(NA, NA), log = "", main = NULL,
#       xlab = deparse(substitute(x)),
#       ylab = deparse(substitute(y)), asp = NA)
# 
# x, y与基本的plot()函数参数一致，指定图中x坐标和y坐标的值；
# ...为每个图层指定其他图形装饰属性，如颜色(colour)、形状(shape)、大小(size)等；
# data用于要分析的数据框；
# facets用来指定用于分面的变量，默认不指定分面变量；
# margins是否呈现图形边缘，默认不显示图形边缘；
# 
# geom为设定的几何对象，几何对象可以是一种，也可以是多种组合，如下为常用的几何对象：
# geom = 'point'，绘制散点图，当参数x和y指定时，默认为散点图；
# geom = 'smooth'，绘制平滑曲线和标准误，method参数可以指定平滑曲线的方法，如lm，loess，gam等；
# geom = 'boxplot'，绘制箱线图，参数colour控制外框颜色，fill指定填充颜色，size调节线的粗细；
# geom = 'path'或geom = 'line'，绘制线图；
# geom = 'histogram'，绘制直方图，当只提供x参数的数据时默认为直方图，可以指定直方图的组距参数binwidth = ，fill参数为直方图添加填充颜色；
# geom = 'freqploy'，绘制频率多变形；
# geom = 'density'，绘制密度曲线，adjust参数控制曲线的平滑程度，取值越大，越平滑；
# geom = 'bar'，绘制条形图，对于明细数据，条形图的纵坐标为频数；对于已经汇总的数据需要使用weight参数指定已汇总的变量；
# geom = 'jitter'，绘制扰动点图，可以查看各位置下的疏密情况，还可以配合alpha = I()参数一起使用，alpha值越小则越透明；
# 
# stat为字符向量，用于指定统计函数；
# position为字符向量，用于调整图形的位置；
# xlim和ylim指定图形横纵坐标的范围，与plot函数中xlim，ylim参数一致；
# log进行横纵坐标的对数转换，可也是log='x'或log='y'或log='xy';
# main为图形添加标题，与plot函数中main参数一致；
# xlab和ylab为图形横纵坐标添加标题，与plot函数中xlab，ylab参数一致。
```

**典型例子：**

下面的例子用到ggplot2包中自带的数据集diamonds

```{r}
#下载并安装ggplot2包
if(!suppressWarnings(require('ggplot2'))){
  install.packages('ggplots')
  require('ggplot2')
  }
head(diamonds)
```

**简单介绍一下数据集中变量的含义：**

carat：砖石的重量（卡拉）
cut：砖石的切工，共有5种水平
color：砖石的颜色，共有7个水平
clarity：砖石的纯度
depth，table，x，y和z为砖石的5种物理指标，深度、宽度等
price：砖石的价格

```{r}
#绘制diamonds数据集中carat与price的散点图
qplot(carat, price, data = diamonds)

#对x和y坐标做对数变换，可以使用log参数
qplot(log(carat), log(price), data = diamonds)

#或者
qplot(carat, price, data = diamonds, log='xy')

#绘制砖石重量与体积的散点图
qplot(carat, x*y*z, data = diamonds)
```

```{r}
#对diamonds数据集进行抽样
set.seed(1234)
dia_sample <- diamonds[
sample(1:nrow(diamonds),1000),]
#为散点图添加图形的其他装饰属性，使用col参数添加颜色
qplot(carat, price, data = dia_sample, col = color)
#为散点图添加图形的其他装饰属性，使用shape参数添加形状属性
qplot(carat, price, data = dia_sample, shape = cut)
```

```{r}
#为散点图添加拟合曲线，使用method参数定义平滑曲线的方法
qplot(carat, price, data = dia_sample,
      geom = c('point','smooth'), method = 'lm')
#loess法，span越小，平滑线越弯曲
qplot(carat, price, data = dia_sample,
      geom = c('point','smooth'),
      method = 'loess', span = 0.2)
```

```{r}
#绘制箱线图,为箱线图添加边缘色（colour参数）和填充色（fill参数）
qplot(color, price/carat, data = diamonds,
      geom = 'boxplot', colour = I('red'),
      fill = I('blue'))
```

```{r}
#绘制线图（这里使用ggplot2包自带的ecnomics数据集，绘制时间序列图）
qplot(date, unemploy/pop, data = economics, geom = 'line')
#或者
qplot(date, unemploy/pop, data = economics, geom = 'path')
```

```{r}
#绘制直方图，使用binwidth参数设置直方图的组距，默认纵坐标为频数
qplot(x = carat, data = diamonds, geom = 'histogram',
      binwidth = 0.1, xlim = c(0,3))
```

```{r}
#用..density..参数设定纵坐标为频率，facets参数实现分面绘图
qplot(x = carat, ..density.., data = diamonds,
      facets = color~., geom = 'histogram',
      binwidth = 0.1, colour = I('black'),
      fill = I('blue'), xlim = c(0,3))
```

```{r}
#绘制密度曲线
qplot(x = carat, data = diamonds, geom = 'density')
qplot(x = carat, data = diamonds, geom = 'density',col = color)
```

```{r}
#绘制条形图，使用fill参数实现叠加条形图的绘制
qplot(x = color, data = diamonds, geom = 'bar', fill = cut)
```

```{r}
#对已经汇总的数据做条形图，需要添加weight参数指定频数
x <- rpois(1000,3)
df <- as.data.frame(table(x))
qplot(x = x, weight = Freq, data = df, geom = 'bar')
```

```{r}
#绘制扰动点图
qplot(x = cut, y = price, data = diamonds, geom = 'jitter')
#添加alpha参数设定透明度
qplot(x = cut, y = price, data = diamonds,
      geom = 'jitter', alpha = I(0.1))
```

从上面的绘图情况来看，根据不同的geom值，可以方便快速的绘制想要的统计图形。然而相比于ggplot2包中的ggplot()函数还是存在明显的缺陷，qplot()函数只能使用一个数据集和一组图形属性映射，而ggplot()函数运用图层的思想，可为每个图层指定不同的数据集和图形属性。

##ggplot()

使用ggplot2包进行统计图形的绘制，绘图过程中主要包括以下四种组件：

1. 数据和图形属性映射
2. 几何对象
3. 统计变换
4. 位置调整

###一、数据（data）和图形属性映射（mapping）

**基本语法：**

```{r}
# ggplot(data = df, mapping = aes(x = , y = , ...))
# 使用ggplot2包进行绘图，对数据的要求必须是数据框，
# 如果数据集发生了变化，可以使用“%+%”来代替原来的数据集；
# aes()参数可以定义图形的属性，这里的属性可以是x轴或y轴所对应数据集的变量，
# 也可以是形状、颜色、尺寸、填充，分组等。
# 需要注意的是，aes()参数所设定的属性值必须是数据集中的变量，不可以是自定义的常量,
# 如果必须要添加属性映射为一个常量，可以做图层函数中添加。
# 还可以通过加号（+）来添加或修改或删除图形属性映射。
```

**典型例子：**

```{r}
library(ggplot2)
library(gridExtra)
# 添加（在ggplot()函数外添加图形映射aes）：
p1 <- ggplot(data = mpg)
p1 <- p1 + aes(x = hwy, y = displ,
               colour = factor(cyl)) + geom_point()
# 修改（将x轴由原来的hwy改为cty）：
p2 <- p1 + aes(x = cty, y = displ,
               colour = factor(cyl)) + geom_point()
# 删除（删除颜色属性的映射）：
p3 <- p1 + aes(x = cty, y = displ, colour = NULL) + geom_point()
# 将三幅图组合到一张图中
grid.arrange(p1, p2, p3, ncol = 3, nrow = 1)
```

有关图形属性映射，这里还想强调一下**分组的属性**，即通过**group参数**实现绘图的分组，**默认情况下group = 1**，表示不对数据进行分组绘图，如果需要指定某个变量为分组变量，则需**将该变量指定给group参数**。这里**需要注意的是**，如果一个变量不能正确实现分组，而多个变量可以准确的将个体进行分组的话，可以使用**interaction()函数**将多个变量组合起来。

**典型例子：**

```{r}
# 通过group = Subject实现每个男孩一条身高增长曲线
library(nlme)
p1 <- ggplot(data = Oxboys, mapping = 
               aes(x = age, y = height, group = Subject)) +
             geom_line()
p1
# 如果不指定分组变量，将会返回无意义的图
p2 <- ggplot(data = Oxboys, mapping =
               aes(x = age, y = height, group = 1)) + geom_line()
p2
# 为每一个男孩的身高增长曲线添加一条线性的平滑曲线显然不能反映所有男孩的趋势
p3 <- ggplot(data = Oxboys, mapping =
               aes(x = age, y = height, group = Subject)) + 
             geom_line() + 
             geom_smooth(mapping = aes(group = Subject),
                         method = 'lm', se = FALSE,
                         size = 2, colour = 'blue')
p3
# 这时绘制所有男孩的平滑曲线时，就不能添加分组属性
p4 <- ggplot(data = Oxboys, mapping =
               aes(x = age, y = height, group = Subject)) +
             geom_line() +
             geom_smooth(mapping = aes(group = 1),
                         method = 'lm', se = FALSE,
                         size = 2, colour = 'blue')
p4
```

###二、几何对象（geom_）

**基本语法：**

```{r}
# 通过加号（+）添加图层函数，实现图层的叠加，以添加条形图图层为例：
#  + geom_bar(mapping = NULL, data = NULL,
#             stat = "bin", position = "stack",...)
# mapping：可以为每个图层添加各自的图形属性映射，用aes()函数包含各种属性映射；
# data：可以为每个图层指定不同的数据集，默认情况下使用ggplot()函数指定的数据集；
# stat：可以为每个图层添加不同的统计变换，对于条形图来说，默认的统计变换封箱bin；
# position：实现图层的位置调整，默认情况下是堆叠图，还可以指定填充图（fill）和并列图（dodge）
# ...：可以指定的其他参数，如透明度、尺寸等。
```

###三、统计变换（stat_）

**基本语法：**

```{r}
# 可以通过加号（+）添加统计变换函数，实现图层上的统计变换，这里以qq图为例：
#  + stat_qq(mapping = NULL, data = NULL,
#            geom = "point",position = "identity",
#            distribution = qnorm, dparams = list(),
#            na.rm = FALSE, ...)
# mapping：为每个统计变换函数添加各自的图形映射；
# data：为每个统计变换函数指定不同的数据集；
# geom：为每个统计变换函数添加不同几何对象，这里默认为点图；
# position：可以实现每个统计变换函数的位置调整；
# distribution：这里指定stat_qq()函数中的分布函数，用字符串表示，默认为正态分位数函数（'qnorm'）；
# dparams：为指定的某种分布的分位数函数设置参数；
# na.rm：为每个统计变换函数选择缺失值的处理方式，默认情况下，剔除缺失值并返回警告信息。
```

**典型例子：**

```{r}
library(ggplot2)
library(gridExtra)
set.seed(1234)
x <- rt(1000,3)
#绘制正态分布的QQ图
p1 <- ggplot(data = NULL, mapping = aes(sample = x)) +
             stat_qq(distribution = qnorm)
#绘制t分布的QQ图
p2 <- ggplot(data = NULL, mapping = aes(sample = x)) +
             stat_qq(distribution = qt, dparams = list(df = 3))
#合并以上两张图
grid.arrange(p1, p2, ncol = 2, nrow = 1)
```

通过图层函数和统计变换函数的介绍，发现每一个几何对象都有一个默认的统计变换，每一个统计变换函数都有一个默认的几何对象，详见《ggplot2：数据分析与图形艺术》一书。

###四、位置调整（position）

**基本语法：**

```{r}
# 位置调整就是对图层元素进行微调，当前ggplot2包含如下5种位置调整参数：
# position = 'dodge'，避免重叠，并排放置；
# position = 'fill'，堆叠图形元素，并将高度标准化为1；
# position = 'stack'，将图形元素堆叠起来；
# position = 'jitter'，给点添加扰动，避免重合；
# position = 'identity'，不对图形元素进行任何调整。
# 位置调整一般多用于处理离散数据，因为连续数据一般很少出现完全重叠的问题。
```

**典型例子：**

```{r}
library(ggplot2)
library(gridExtra)
#堆叠条形图
bar_stack <- ggplot(data = mtcars,
                    mapping = aes(x = factor(am),
                                  fill = factor(cyl))) + 
                    geom_bar(stat = 'count', position = 'stack')
#填充条形图
bar_fill <- ggplot(data = mtcars,
                   mapping = aes(x = factor(am),
                                 fill = factor(cyl))) + 
                   geom_bar(stat = 'count', position = 'fill')
#并列条形图
bar_bodge <- ggplot(data = mtcars,
                    mapping = aes(x = factor(am),
                                  fill = factor(cyl))) + 
                    geom_bar(stat = 'count', position = 'dodge')
#合并三张图为一张图
grid.arrange(bar_stack, bar_fill, bar_bodge, ncol = 3, nrow = 1)
```

以上便是ggplot2的基本概念及用法，下面将详细介绍绘制不同种类图形的方法。

#ggplot2绘制散点图

散点图可以用来描述两个连续变量之间的关系，一般在做数据探索分析时会使用到，通过散点图发现变量之间的相关性强度、是否线性关系等。

##绘制简单的散点图

ggplot包中的**geom_point()函数**可以非常方便绘制出所需的散点图。

```{r}
library(ggplot2)
set.seed(1234)
x <- rnorm(100,mean = 2, sd = 3)
y <- 1.5 + 2*x + rnorm(100)
df <- data.frame(x = x, y = y)
ggplot(data = df, mapping = aes(x = x, y = y)) + geom_point()
```

##绘制分组的散点图

可将分组变量(因子或字符变量)赋值给颜色或形状属性，实现分组散点图的绘制

```{r}
set.seed(1234)
x <- rnorm(100,mean = 2, sd = 3)
y <- 1.5 + 2*x + rnorm(100)
z <- sample(c(0,1), size = 100, replace = TRUE)
df <- data.frame(x = x, y = y, z = z)
# 将数值型变量转换为因子型变量
df$z <- factor(df$z)
# 分组变量赋值给颜色属性
ggplot(data = df, mapping = aes(x = x, y = y, colour = z)) + geom_point(size = 3)
# 分组变量赋值给形状属性
ggplot(data = df, mapping = aes(x = x, y = y, shape = z)) + geom_point(size = 3)
```

用户可能对默认的颜色或形状不满意，可以通过**scale_colour_brewer()或scale_colour_manual()函数自定义点的颜色**；通过**scale_shape_manual()函数实现自定义点的形状**。为了说明问题，这里将分组变量同时赋值给颜色属性和形状属性。

```{r}
ggplot(data = df, mapping = aes(x = x, y = y, colour = z, shape = z)) + geom_point(size = 3) +                  scale_color_brewer(palette = 'Accent') + scale_shape_manual(values = c(2,16))
```

以上几种图形是将离散变量或因子映射给颜色属性或形状属性，下面介绍如何将连续变量映射给颜色属性或大小属性。

```{r}
x <- c(10,13,11,15,18,20,21,22,24,26)
y <- c(76,60,70,58,55,48,44,40,26,18)
z <- c(100,120,300,180,80,210,30,95,145,420)
df <- data.frame(x = x, y = y, z = z)
#将连续变量映射给颜色属性
ggplot(data = df, mapping = aes(x = x, y = y, colour = z)) + geom_point(size = 3)
```

但这里发现一个问题，颜色越深而对应的值越小，如何将值的大小与颜色的深浅保持一致呢？很简单，只需人为的设置色阶，从低到高设置不同的颜色即可。

```{r}
ggplot(data = df, mapping = aes(x = x, y = y, colour = z)) + geom_point(size = 3) +
       scale_colour_gradient(low = 'lightblue', high = 'darkblue')
```

```{r}
#将连续变量映射给大小属性
ggplot(data = df, mapping = aes(x = x, y = y, size = z)) + geom_point()
```

上面将连续变量赋值给颜色属性或大小属性，我们还可以人为的设置色阶间隔或大小间隔。

```{r}
#自定义色阶间隔
ggplot(data = df, mapping = aes(x = x, y = y, fill = z)) + 
       geom_point(shape = 21, size = 3) +
       scale_fill_continuous(low = 'lightblue', high = 'darkblue', breaks =
                               c(100,150,200,300,350,400))
#自定义球大小的间隔
ggplot(data = df, mapping = aes(x = x, y = y, size = z)) + 
       geom_point() +
       scale_size_continuous(breaks = c(100,150,200,300,350,400), 
                             guide = guide_legend())
```

```{r}
#将连续变量值的大小与球的大小成比例
ggplot(data = df, mapping = aes(x = x, y = y, size = z)) + 
       geom_point() +
       scale_size_area(max_size = 10)
```

很明显，使用第二种球大小的图看起来更舒服，也更明显。

##重叠点的处理

当数据点非常多时，可能会导致数据点重叠非常严重，该如何处理这样的问题呢？一般有以下几种方法：

1. 使用半透明的点
2. 数据分箱，并用矩形表示
3. 数据分箱，并用六边形表示
4. 使用二维密度估计，并将等高线添加到散点图中
5. 向散点图中添加边际地毯

```{r}
set.seed(1234)
x <- rnorm(10000)
y <- rnorm(10000,0,2)
df <- data.frame(x = x, y = y)
#不作任何处理
ggplot(data = df, mapping = aes(x = x, y = y)) + geom_point()
```

```{r}
#使用透明度处理点的重叠问题
ggplot(data = df, mapping = aes(x = x, y = y)) + geom_point(alpha = 0.1)
#分箱，并用矩阵表示
ggplot(data = df, mapping = aes(x = x, y = y)) + stat_bin2d()
```

**默认情况下，stat_bin_2d()函数将x轴和y轴的数据点各分为30个段，即参数900个箱子**，用户还可以自定义分段个数,以及箱子在垂直和水平方向上的宽度。

```{r}
#设置bins为50
ggplot(data = df, mapping = aes(x = x, y = y)) + stat_bin2d(bins = 50) +
       scale_fill_gradient(low = 'steelblue', high = 'darkred', limits = c(0,100), breaks = 
                             c(0,25,50,100))
```

将图形划分为小的正方形箱可能会产生分散注意力的视觉假象，**一般建议使用六边形代之**。

```{r}
#分箱，并用六边形表示
ggplot(data = df, mapping = aes(x = x, y = y)) + 
       stat_binhex(binwidth = c(0.2,0.3)) + 
       scale_fill_gradient(low = 'lightgreen', high = 'darkred', 
                           limits = c(0,100), breaks =
                           c(0,25,50,100))
```

```{r}
#使用stat_density2d作二维密度估计，并将等高线添加到散点图中
ggplot(data = df, mapping = aes(x = x, y = y)) + 
       geom_point() + 
       stat_density2d()
#使用大小与分布密度成正比例的点
ggplot(data = df, mapping = aes(x = x, y = y)) + 
       stat_density2d(geom = 'point', 
                      aes(size = ..density..), 
                      contour = FALSE) + 
       scale_size_area()
```

```{r}
#使用热图展示数据分布密度情况
ggplot(data = df, mapping = aes(x = x, y = y)) + 
       stat_density2d(geom = 'tile', 
                      aes(fill = ..density..), contour = FALSE)
```

```{r}
#向散点图中添加边际地毯
ggplot(data = faithful, mapping = aes(x = eruptions, y = waiting)) + 
       geom_point() +
       geom_rug()
```

通过边际地毯，可以快速查看每个坐标轴上数据的分布密疏情况。还可以通过向边际地毯线的位置坐标添加扰动并设定size减少线宽，从而减轻边际地毯线的重叠程度。

```{r}
ggplot(data = faithful, mapping = aes(x = eruptions, y = waiting)) + 
       geom_point() +
       geom_rug(position = 'jitter', size = 0.1)
```

如果一个变量为离散变量，另一个变量为连续变量时，如何绘制散点图？

```{r}
set.seed(1234)
x <- rep(1:5, each = 1000)
y <- c(rnorm(1000),rnorm(1000,1,2),rnorm(1000,3,4),rt(1000,2),rt(1000,4))
df <- data.frame(x = x, y = y)
df$x <- factor(df$x)
#不作任何处理的散点图
ggplot(data = df, mapping = aes(x = x, y = y)) + geom_point()
```

对于这样的图，似乎没有什么意义，为了避免过度重叠，有以下两种处理方法：

1. 使用扰动图
2. 使用箱线图(适用于一个或两个变量为离散变量)

```{r}
#给数据点添加随机扰动
ggplot(data = df, mapping = aes(x = x, y = y)) + geom_point(position = 'jitter')
```

默认情况下，扰动函数在每个方向（水平和垂直）上添加的扰动值为数据点最小精度的40%，当然也可以通过width和height参数自定义扰动量。

```{r}
# 水平方向上添加50%的扰动量
ggplot(data = df, mapping = aes(x = x, y = y)) + 
       geom_point(position = position_jitter(width = 0.5, height = 0))
```

```{r}
#绘制箱线图
ggplot(data = df, mapping = aes(x = x, y = y)) + 
       geom_boxplot(mapping = aes(group = x),
       fill = 'steelblue')
```

**这里需要提醒的是**，横坐标为数值型变量时，必须要将其转换为因子，并在**geom_boxplot()函数的属性中将因子映射给group**，否则产生的效果图将是错误的。

上文中提到，通过绘制两个变量的散点图可以查看变量将的关系，可以是线性的也可以是非线性的，如何在散点图的基础上再添加拟合曲线呢？下文将逐一介绍几种拟合线。

```{r}
#不添加任何拟合线
ggplot(data = iris, mapping = aes(x = Petal.Length, y = Petal.Width, colour = Species)) +
       geom_point()
#添加线性拟合线
ggplot(data = iris, mapping = aes(x = Petal.Length, y = Petal.Width, colour = Species)) +
       geom_point() + stat_smooth(method = 'lm')
#添加局部加权多项式曲线
ggplot(data = iris, mapping = aes(x = Petal.Length, y = Petal.Width, colour = Species)) +
       geom_point() + stat_smooth(method = 'loess')
```

```{r}
#添加Logistic曲线
library(MASS)
b <- biopsy
#绘制Logistic曲线必须将因变量强制转换为0-1
b <- transform(b, class_trans = ifelse(class == 'benign', 0, 1))
ggplot(data = b, mapping = aes(x = V1, y = class_trans)) + 
       geom_point(position =position_jitter(width = 0.3, height = 0.06), 
                  alpha = 0.4, shape = 21, size = 2) +
       stat_smooth(method = glm, method.args = list(family = "binomial"))
```

**如果不需要为拟合线绘制置信区间的话**，置信将stat_smooth()函数中的参数se设为FALSE即可。

如果两个变量均是离散变量，该如何绘制散点图？实质上，这样的散点图我们称作气泡图。一般可以将这种图应用到价值转移中。

```{r}
value1 <- rep(c('高价值','中价值','低价值'), each = 3)
value2 <- rep(c('高价值','中价值','低价值'), times = 3)
nums <- c(500,287,123,156,720,390,80,468,1200)
df <- data.frame(value1 = value1, value2 = value2, nums = nums)
df$value1 <- factor(df$value1, levels = c('高价值','中价值','低价值'), order = TRUE)
df$value2 <- factor(df$value2, levels = c('低价值','中价值','高价值'), order = TRUE)
ggplot(data = df, mapping = aes(x = value1, y = value2, size = nums)) +
       geom_point(colour = 'steelblue') + scale_size_area(max_size = 30, guide = FALSE) +
       geom_text(aes(label = nums), vjust = 0, colour = 'black', size = 5)
```

从图中可知，高价值用户中有80个流向了低价值，而低价值用户中又有128个流向高价值。

最后再介绍两种比较常用的种散点图，即**Cleveland点图和散点图矩阵**。
在《手把手教你使用ggplot2绘制条形图》我们向大家介绍了然后绘制各种各样的条形图，这里介绍另一种替代条形图的Cleveland点图。**通过Cleveland点图可以减少图形造成的视觉混乱，同时图形更具可读性**。

```{r}
set.seed(1234)
names <- letters
Score <- runif(26, min = 55, max = 90)
df <- data.frame(names = names, Score = Score)
#条形图
ggplot(data = df, mapping = aes(x = reorder(names,Score), y = Score)) + 
       geom_bar(stat = 'identity', fill = 'steelblue', colour = 'black') + 
       xlab('Name') + geom_text(aes(label = round(Score)), vjust = 1)
#Cleveland点图
ggplot(data = df, mapping = aes(x = reorder(names,Score), y = Score)) + 
       geom_point(size = 5, shape = 21, fill = 'steelblue', colour = 'black') + 
       xlab('Name')
```

散点图矩阵是一种对多个变量两两之间关系进行可视化的有效方法，R中pairs()函数可以实现这样的需求。

```{r}
#使用pairs()函数绘制散点图矩阵
data(tips, package = "reshape")
pairs(tips[,1:3])

#使用car包中的scatterplot.matrix()函数
library(car)
scatterplot.matrix(tips[,1:3])

#使用GGally包中的ggpairs()函数绘制散点图矩阵
library(GGally)
ggpairs(tips[, 1:3])
```

通过GGally包中的ggpairs()函数绘制散点图矩阵还是非常引入入目的，将连续变量和离散变量非常完美的结合在一起。

#ggplot2绘条形图

数据分析报告中经常会看见各种各样的条形图，如简单条形图、水平交错条形图、堆叠条形图、堆叠百分比条形图等，本文从R语言的角度，教大家绘制各式各样的条形图。

##绘制离散单变量的条形图

从数据形式来看：**有汇总好的数据集和明细数据集**

###使用汇总好的数据集绘制条形图：

```{r}
x <- c('A','B','C','D','E') 
y <- c(13,22,16,31,8) 
df <- data.frame(x= x, y = y)
ggplot(data = df, mapping = aes(x = x, y = y)) + geom_bar(stat= 'identity')
```

对于条形图的y轴就是数据框中原本的数值时，**必须将geom_bar()函数中stat(统计转换)参数设置为’identity’**，即对原始数据集不作任何统计变换，而该参数的默认值为’count’，即观测数量。

###使用明细数据集绘制条形图：

```{r}
set.seed(1234) 
x <- sample(c('A','B','C','D'), size = 1000, replace= TRUE, prob = c(0.2,0.3,0.3,0.2)) 
y <- rnorm(1000) * 1000
df = data.frame(x= x, y = y) 
ggplot(data = df, mapping = aes(x = x)) + geom_bar(stat = 'count')
```

数据集本身是明细数据，而对于统计某个离散变量出现的频次时，geom_bar()函数中stat(统计转换)参数只能设置为默认，即’count’。

**从x轴的数据类型来看：有字符型的x值也有数值型的x值**

上面的两幅图对应的x轴均为离散的字符型值，如果x值是数值型时，该如何正确绘制条形图？

```{r}
set.seed(1234) 
x <- sample(c(1,2,4,6,7), size = 1000, replace = TRUE,prob = c(0.1,0.2,0.2,0.3,0.2)) 
ggplot(data = data.frame(x = x), mapping= aes(x = x, y = ..count..)) + geom_bar(stat = 'count')
```

如果直接使用数值型变量作为条形图的x轴，我们会发现条形图之间产生空缺，这个空缺其实对应的是3和5两个值，这样的图形并不美观。为了能够使条形图之间不存在类似的空缺，**需要将数值型的x转换为因子**，即factor(x)，如下图所示：

```{r}
ggplot(data = data.frame(x = x), mapping = aes(x = factor(x), y = ..count..))+ geom_bar(stat = 'count')
```

上面几幅图的颜色均为灰色的，显得并不是那么亮眼，为了使颜色更加丰富多彩，可以在geom_bar()函数内通过**fill参数可colour参数**设置条形图的填充色和边框色，例如：

```{r}
ggplot(data = data.frame(x = x), mapping = aes(x = factor(x), y = ..count..))+ geom_bar(stat = 'count', fill = 'steelblue', colour = 'darkred')
```

关于颜色的选择可以在R控制台中输入**colours()**，将返回657种颜色的字符。如果想查看所有含红色的颜色值，可以**输入colours()[grep(‘red’,colours())]**返回27种红色。

##绘制簇条形图

以上绘制的条形图均是基于一个离散变量作为x轴，如果想绘制两个离散变量的条形图即簇条形图该如何处理呢？具体见下方例子：

```{r}
x <- rep(1:5, each = 3) 
y <- rep(c('A','B','C'),times = 5) 
set.seed(1234)
z <- round(runif(min = 10, max = 20, n = 15)) 
df <- data.frame(x= x, y = y, z = z) 
ggplot(data = df, mapping = aes(x = factor(x), y = z,fill = y)) + 
       geom_bar(stat = 'identity', position = 'dodge')
```

对于簇条形图**只需在ggplot()函数的aes()参数中将其他离散变量赋给fill参数即可**。这里的position参数表示条形图的摆放形式，默认为堆叠式(stack)，还可以是百分比的堆叠式。下面分别设置这两种参数，查看一下条形图的摆放形式。

###堆叠式：

```{r}
ggplot(data = df, mapping = aes(x = factor(x), y = z, fill = y)) + geom_bar(stat= 'identity', position = 'stack')
```

发现一个问题，**条形图的堆叠顺序与图例顺序恰好相反**，这个问题该如何处理呢？很简单，只需再添加guides()函数进行设置即可，如下所示：

```{r}
ggplot(data = df, mapping = aes(x = factor(x), y = z, fill = y)) + geom_bar(stat= 'identity', position = 'stack') + guides(fill = guide_legend(reverse= TRUE))
```

guides()函数将图例引到fill属性中，再使图例反转即可。

###百分比堆叠式：

```{r}
ggplot(data = df, mapping = aes(x = factor(x), y = z, fill = y)) + 
       geom_bar(stat= 'identity', position = 'fill')
```

##颜色配置：

同样，如果觉得R自动配置的填充色不好看，还可以根据自定义的形式更改条形图的填充色，具体**使用scale_fill_brewer()和scale_fill_manual()函数**进行颜色设置。

scale_fill_brewer()函数使用R自带的ColorBrewer画板

```{r}
ggplot(data = df, mapping = aes(x = factor(x), y = z, fill = y)) + 
       geom_bar(stat= 'identity', position = 'dodge') + 
       scale_fill_brewer(palette = 'Accent')
```


具体的调色板颜色可以查看scale_fill_brewer()函数的帮助。

scale_fill_manual()函数允许用户给指定的分类水平设置响应的色彩，个人觉得这个比较方便

```{r}
col <- c('darkred','skyblue','purple')
ggplot(data = df, mapping =aes(x = factor(x), y = z, fill = y)) + 
       geom_bar(stat = 'identity', colour= 'black', position = 'dodge') +
       scale_fill_manual(values = col, limits= c('B','C','A')) + 
       xlab('x')
```

##该如何绘制有序的条形图？

```{r}
#不经排序的条形图，默认按x值的顺序产生条形图 
x <- c('A','B','C','D','E','F','G') 
y <- c('xx','yy','yy','xx','xx','xx','yy') 
z <- c(10,33,12,9,16,23,11) 
df <- data.frame(x = x, y = y, z = z) 
ggplot(data = df, mapping = aes(x= x, y = z, fill = y)) + 
       geom_bar(stat = 'identity')
```

按z值的大小，重新排列条形图的顺序，只需将aes()中x的属性用reorder()函数更改即可。

```{r}
ggplot(data = df, mapping = aes(x = reorder(x, z), y = z, fill = y)) + 
       geom_bar(stat = 'identity') + xlab('x')
```

##关于条形图的微调

###如何y轴的正负值区分开来，并去除图例

```{r}
set.seed(1234) 
x = 1980 + 1:35 
y = round(100*rnorm(35)) 
df <- data.frame(x= x, y = y) 
#判断y是否为正值 
df <- transform(df, judge=ifelse(y>0,'Yes', 'No'))
ggplot(data = df, mapping = aes(x = x, y = y, fill = judge)) + 
       geom_bar(stat = 'identity', position = 'identity') + 
       scale_fill_manual(values = c('blue','red'), guide = FALSE) + 
       xlab('Year')
```

stat参数和position参数均设置为identity，目的是图形绘制不要求对原始数据做任何的变换，包括统计变换和图形变换，排除图例可以通过scale_fill_manual()函数将参数guide设置为FALSE，同时该函数还可以自定义填充色，一举两得。

###调整条形图的条形宽度和条形间距

geom_bar()函数可以非常灵活的将条形图的条形宽度进行变宽或变窄设置,具体通过函数的width参数实现，width的最大值为1，默认为0.9。

```{r}
x = c('A','B','C','D','E') 
y = c(10,20,15,22,18) 
df <- data.frame(x = x, y = y) 
#不作任何条形宽度的调整 
ggplot(data = df, mapping = aes(x = x, y = y)) + 
       geom_bar(stat = 'identity', fill = 'steelblue', colour = 'black')
```

```{r}
#使条形宽度变宽
ggplot(data = df, mapping = aes(x = x, y = y)) + 
       geom_bar(stat = 'identity', fill = 'steelblue', colour = 'black', width = 1)
```

对于簇条形图来说，还可以调整条形之间的距离，默认情况下，条形图的组内条形间隔为0，具体可通过函数的position_dodge参数实现条形距离的调整，为了美观，一般将条形距离设置的比条形宽度大一点。

```{r}
x <- rep(1:5, each = 3) 
y <- rep(c('A','B','C'),times = 5) 
set.seed(1234)
z <- round(runif(min = 10, max = 20, n = 15)) 
df <- data.frame(x= x, y = y, z = z) 
#不作任何条形宽度和条形距离的调整 
ggplot(data = df, mapping = aes(x= factor(x), y = z, fill = y)) + 
       geom_bar(stat = 'identity', position ='dodge')
```


```{r}
#调整条形宽度和条形距离
ggplot(data = df, mapping = aes(x = factor(x), y = z, fill = y)) + 
       geom_bar(stat= 'identity', width = 0.5, position = position_dodge(0.7))
```

###添加数据标签

geom_text()函数可以方便的在图形中添加数值标签，具体微调从几个案例开始：

```{r}
x <- rep(1:5, each = 3) 
y <- rep(c('A','B','C'),times = 5)
set.seed(1234)
z <- round(runif(min = 10, max = 20, n = 15)) 
df <- data.frame(x= x, y = y, z = z) 
ggplot(data = df, mapping = aes(x = interaction(x,y), y = z, fill = y)) + 
       geom_bar(stat = 'identity') + 
       geom_text(mapping = aes(label= z))
```

除此之外，还可以**调整标签的大小、颜色、位置等**。

```{r}
ggplot(data = df, mapping = aes(x = interaction(x,y), y = z, fill = y))+ 
       geom_bar(stat = 'identity') + 
       ylim(0,max(z)+1) + 
       geom_text(mapping =aes(label = z), size = 8, colour = 'orange', vjust = 1)
```

ylim设置条形图中y轴的范围；**size调整标签字体大小**，默认值为5号；**colour更换标签颜色**；**vjust调整标签位置**，1为分界线，越大于1，标签越在条形图上界下方，反之则越在条形图上上界上方。

对于水平交错的簇条形图，必须通过geom_text()函数中的position_dodge()参数来调整标签位置，**hjust=0.5将标签水平居中放置**。

```{r}
ggplot(data = df, mapping = aes(x = x, y = z, fill = y)) + geom_bar(stat
= 'identity', position = 'dodge') + geom_text(mapping = aes(label = z),
size = 5, colour = 'black', vjust = 1, hjust = .5, position = position_dodge(0.9))
```

**这里的图形位置与标签位置摆放必须一致**，即图形位置geom_bar()函数中的position = ‘dodge’参数，标签位置geom_text()函数中的position = position_dodge(0.9)参数。

对于堆叠的簇条形图，必须通过geom_text()函数中的position_stack()参数来调整标签位置，hjust将标签水平居中放置。

```{r}
ggplot(data = df, mapping = aes(x = x, y = z, fill = y)) + 
       geom_bar(stat = 'identity', position = 'stack') + 
       geom_text(mapping = aes(label = z),size = 5, colour = 'black', 
                 vjust = 3.5, hjust = .5, position = position_stack())
```

**这里的图形位置与标签位置摆放必须一致**，即图形位置geom_bar()函数中的position = ‘stack’参数，标签位置geom_text()函数中的position = position_stack()参数。